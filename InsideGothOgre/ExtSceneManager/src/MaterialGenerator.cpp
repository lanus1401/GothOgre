#include "Precompiled.h"
#include "MaterialGenerator.h"
#include "SceneManagerExImpl.h"


namespace GothOgre
{
	//--------------------------------------------------------------------------
	static const String PREFIX_FOR_AUTOGENERATED_MATERIALS = "Auto";
	NameGenerator MaterialGenerator::ms_NameGenerator(PREFIX_FOR_AUTOGENERATED_MATERIALS);
	//-----------------------------------------------------------------------
	MaterialGenerator::MaterialGenerator( SceneManagerExImpl* _sceneManager )
	{
		mSceneManager = _sceneManager;
		mNumCreatedMaterials = 0;
		mNumDestroyedMaterials = 0;
	}
	//-----------------------------------------------------------------------
	MaterialGenerator::~MaterialGenerator()
	{
		MaterialManager::getSingleton().removeUnreferencedResources();
		
		if( mNumDestroyedMaterials != mNumCreatedMaterials )
		{
			GOTHOGRE_WARNING( "Some materials were created but not destroyed "
				<< "(num_created: " << mNumCreatedMaterials 
				<< ", num_destroyed: " << mNumDestroyedMaterials << ")" );
		}
	}
	//-----------------------------------------------------------------------
	void MaterialGenerator::increaseNumberOfCreatedMaterials()
	{
		++mNumCreatedMaterials;
	}
	//-----------------------------------------------------------------------
	void MaterialGenerator::increaseNumberOfDestroyedMaterials()
	{
		++mNumDestroyedMaterials;
	}
	//-----------------------------------------------------------------------
	MaterialGenerator::MaterialMap& 
		MaterialGenerator::getMaterialMap( const MtlPtr& _mtl )
	{
		return getMaterialMap( _mtl, mSceneManager );
	}
	//-----------------------------------------------------------------------
	MaterialGenerator::MaterialMap& 
		MaterialGenerator::getMaterialMap( 
			const MtlPtr& _mtl, SceneManagerExImpl* _sceneManager )
	{
		UserObjectBindings& uob = _mtl->getUserObjectBindings();
		static const String ANY_NAME = "MMapBySM";
		
		MaterialMapBySceneManager* mmapBySM 
			= uob.getUserAny( ANY_NAME ).getPtr<MaterialMapBySceneManager>();

		if(!mmapBySM)
		{
			uob.setUserAny( ANY_NAME, (AnyLite) MaterialMapBySceneManager() );
			mmapBySM = uob.getUserAny( ANY_NAME ).getPtr<MaterialMapBySceneManager>();
		}

		MaterialMapBySceneManager::iterator it = mmapBySM->find( _sceneManager );
		if( it == mmapBySM->end() )
		{
			it = mmapBySM->insert( std::make_pair( _sceneManager, MaterialMap()) ).first;
		}
		
		MaterialMap& materialMap = it->second;
		return materialMap;
	}
	//-----------------------------------------------------------------------
	MaterialGenerator::MatGenInfoHolder& MaterialGenerator::getMatGenInfoHolder( const MaterialPtr& _material )
	{
		if( _material->getNumTechniques() == 0 )
		{
			_material->createTechnique();
		}
		
		Technique* technique = _material->getTechnique(0);

		UserObjectBindings& uob = technique->getUserObjectBindings();
		static const String ANY_NAME = "MatGenInfo";
		MatGenInfoHolder* holder = uob.getUserAny( ANY_NAME ).getPtr<MatGenInfoHolder>();

		if(!holder)
		{
			uob.setUserAny( ANY_NAME, (AnyLite) MatGenInfoHolder() );
			holder = uob.getUserAny( ANY_NAME ).getPtr<MatGenInfoHolder>();
		}
		
		return *holder;
	}
	//-----------------------------------------------------------------------
	MaterialPtr MaterialGenerator::generateMaterial( const MtlPtr& _mtl, const MatGenParams& _matGenParams )
	{
		return generateMaterial( _mtl, _matGenParams, mSceneManager );
	}
	//-----------------------------------------------------------------------
	MaterialPtr MaterialGenerator::generateMaterial( const MtlPtr& _mtl, const MatGenParams& _matGenParams, SceneManagerExImpl* _sceneManager )
	{
		MaterialMap& materialMap = getMaterialMap( _mtl, _sceneManager );
		
		MaterialMap::iterator it = materialMap.find( &_matGenParams );
		if( it != materialMap.end() )
		{
			ResourceHandle handle = it->second;
			MaterialPtr material = MaterialManager::getSingleton().getByHandle( handle );
			return material;
		}

		String materialName = ms_NameGenerator.generate();
		MaterialPtr material = MaterialManager::getSingleton().create( materialName, ResourceGroup::MANUAL, true );

		// Statistics
		MaterialGenerator* mg = _sceneManager->_getMaterialGenerator();
		mg->increaseNumberOfCreatedMaterials();

		//
		mg->setupMaterial( *material.get(), _mtl, _matGenParams );

		MatGenInfoHolder& matGenInfoHolder = getMatGenInfoHolder( material );
		matGenInfoHolder.mtl = _mtl;
		matGenInfoHolder.matGenParams = _matGenParams;
		matGenInfoHolder.sceneManager = _sceneManager;

		materialMap.insert( std::make_pair( &matGenInfoHolder.matGenParams, material->getHandle() ));
		matGenInfoHolder.setInitialised();

		return material;
	}
	//-----------------------------------------------------------------------
	MaterialPtr MaterialGenerator::generateMaterial(const MatGenInfo& _matGenInfo)
	{
		return generateMaterial( 
			_matGenInfo.mtl, 
			_matGenInfo.matGenParams, 
			(SceneManagerExImpl*) _matGenInfo.sceneManager );
	}
	//-----------------------------------------------------------------------
	MaterialGenerator::MaterialIterator MaterialGenerator::getGeneratedMaterialIterator(const MtlPtr& _mtl)
	{
		MaterialMap& materialMap = getMaterialMap( _mtl );
		return MaterialIterator( materialMap );
	}
	//-----------------------------------------------------------------------
	void MaterialGenerator::updateMaterials(const MtlPtr& _mtl)
	{
		MaterialIterator iterator = getGeneratedMaterialIterator( _mtl );
		while( iterator.hasMoreElements() )
		{
			const MatGenParams& matGenParams = iterator.peekNextKey();
			MaterialPtr material = iterator.getNext();
			setupMaterial( *material.get(), _mtl, matGenParams );
		}
	}
	//-----------------------------------------------------------------------
	void MaterialGenerator::updateMaterial(const MaterialPtr& _material, const MatGenParams& _newMatGenParams)
	{
		MatGenInfoHolder& matGenInfoHolder = getMatGenInfoHolder( _material );
		MtlPtr mtl = matGenInfoHolder.mtl;

		setupMaterial( *_material.get(), mtl, _newMatGenParams );

		MaterialMap& materialMap = getMaterialMap( mtl );
		MatGenParams& oldMatGenParams = matGenInfoHolder.matGenParams;

		MaterialMap::iterator it = materialMap.find( &oldMatGenParams );
		if( it != materialMap.end() )
			materialMap.erase( it );

		matGenInfoHolder.matGenParams = _newMatGenParams;
		materialMap.insert( std::make_pair( &matGenInfoHolder.matGenParams, _material->getHandle() ));
	}
	//-----------------------------------------------------------------------
	const MatGenInfo& MaterialGenerator::getMatGenInfo(const MaterialPtr& _material)
	{
		MatGenInfoHolder& matGenInfoHolder = getMatGenInfoHolder( _material );
		return matGenInfoHolder;
	}
	//-----------------------------------------------------------------------
	void MaterialGenerator::MatGenInfoHolder::removeReferenceFromMtl()
	{
		if(mInitialised)
		{
			SceneManagerExImpl* sm = (SceneManagerExImpl*) sceneManager;
			MaterialMap& materialMap = getMaterialMap( mtl, sm );
			MaterialMap::iterator it = materialMap.find( &matGenParams );
			if( it != materialMap.end() )
			{
				materialMap.erase( it );

				MaterialGenerator* mg = sm->_getMaterialGenerator();
				mg->increaseNumberOfDestroyedMaterials();
			}
		}
	}

} // namespace GothOgre
